package com.kh.array.team;

import java.util.Arrays;
/*
 * 1. 합병 정렬
 *  1) 배열의 중간 부분을 기준으로 왼쪽부터 쪼갠다. [8, 2, 5, 3, 4, 7, 6, 1] -> [8, 2, 5, 3] [4, 7, 6, 1]
 *  2) 배열을 쪼갤 때 배열의 중간 부분을 기준으로 왼쪽부터 배열이 쪼갤 수 없을 때 까지 쪼갠다. [8 2] [5 3] -> [8] [2] 
 *  3) 맨 왼쪽의 두 원소를 대소 비교를 하여 합친다. [2 8]
 *  4) 왼쪽의 두 원소를 대소 비교를 하여 합쳤다면 그 나머지 원소들도 비교를 하여 합친다. [5] [3] -> [3 5]
 *  5) 그리고 정렬된 두 배열을 대소 비교를 하여 합친다.  [2 8] [3 5] -> [2, 3, 5, 8]
 *  6) 전체 배열의 중간을 기준으로 왼쪽의 배열이 정렬되어 병합되었으면 전체 배열의 중간을 기준으로 오른쪽 배열을 분할한다. [4, 7, 6, 1]
 *  7) 배열의 중간을 기준으로 왼쪽을 분할 정복 하듯이 똑같이 오른쪽도 진행해 준다. [1, 4, 6, 7]
 *  8) 마지막으로 첫 번째 전체 배열을 중간을 기준으로 두 개의 배열로 나눴던 곳으로 돌아오게 된다면 거기서도 병합을 진행한다.[2, 3, 5, 8] [1, 4, 6, 7] -> [1, 2, 3, 4, 5, 6, 7, 8]
 *  
 *  
 *  
 * 2. 정렬, 병합 방법
 *   - 만약 왼쪽의 4크기의 배열 오른쪽의 4크기의 배열이 있다고 가정하자 (왼쪽과 오른쪽의 배열은 전부 병합되면서 정렬이 완료된 상태)
 *   [2, 3, 5, 8] [1, 4, 6, 7]
 *   - 왼쪽배열의 2와 오른쪽 배열의 1을 비교하여 전체 배열에 첫 번째 index에 넣는다.
 *   - 오른쪽 배열의 원소가 더 작으니 오른쪽 배열의 인덱스는 하나 더해져 두번째 인덱스로 이동하고 왼쪽 배열의 원소는 더 크니 인덱스를 유지한다.
 *   - 왼쪽 배열의 첫 번째 원소와 오른쪽 배열의 두번째 원소를 비교했을 때, 왼쪽 배열의 첫 번째 인덱스가 더 작으니 왼쪽 배열의 인덱스를 하나 더하고 전체 배열에 첫 번째 index에 삽입
 *   - 이런식으로 진행하다 보면 한 쪽의 배열에는 비교가 안된 원소들이 남게되는데 그 원소들을 전체배열에 하나씩 차례대로 추가하면 끝
 *   
 *    EX) [8, 2, 5, 3, 4, 7, 6, 1]의 sort 순서
 *   - [8, 2, 5, 3, 4, 7, 6, 1] -> [8, 2, 5, 3][4, 7, 6, 1] -> [8, 2][5, 3] -> [8][2] -> merge[2, 8]
 *   -> [2, 8][5, 3] -> [5][3] -> merge[3, 5]
 *   -> [2, 8] [3 5] -> merge [2, 3, 5, 8] 
 *   -> [2, 3, 5, 8][4, 7, 6, 1] -> [4, 7][6, 1] -> [4][7] -> merge[4, 7] 
 *   -> [4, 7][6, 1] -> [6][1] -> merge[1, 6] 
 *   -> [4, 7][1, 6] merge[1, 4, 6, 7] 
 *   -> [2, 3, 5, 8][1, 4, 6, 7] -> merge[1, 2, 3, 4, 5, 6, 7, 8] 
 *   
 *   
 * 3. 시간 복잡도와 공간 복잡도
 *   1) 시간 복잡도
 *   식 : O(nlogn)
 *   - 설명 : 깊이는 logN 만약에 N(배열의 크기)이 8이면 3번 병합을 진행한다. 폭은 N 이므로 깊이 x 폭 = nlogn
 *   
 *   2) 공간 복잡도
 *   식 : O(n)
 *   - 설명 : 병합 정렬은 공간이 줄어들거나 커질 일이 없으므로 n(배열의 크기)으로 고정
 */

public class Merge {
	public static void main(String[] args) {
			int[] array = {8, 2, 5, 3, 4, 7, 6, 1};
			System.out.println(Arrays.toString(array));
			mergesort(array);
			System.out.println(Arrays.toString(array));
	}
	
	// 배열을 분할해주기 위한 메소드
		public static void mergesort(int[] array) {
			int length = array.length;                     
			if(length <= 1) return;                        // 배열의 길이가 1이라는 것은 비교할 대상이 없으므로 이전으로 되돌아간다. 
			
			int middle = length / 2;                       // 배열의 중간을 나누기 위한 연산
			int[] leftArray = new int[middle];             // 왼쪽 배열을 배열 중앙을 기준으로 나눔
			int[] rightArray = new int[length - middle];   // 오른쪽 배열을 배열 중앙을 기준으로 나눔
			
			int i = 0; // left array index                 // 왼쪽 배열을 leftArray에 담기위한 index
			int j = 0; // right array index                // 오른쪽 배열을 leftArray에 담기위한 index
			
			//절반을 나눈 값을 왼쪽 배열과 오른쪽 배열에 넣는다.
			for(i = 0; i < length ; i++) {     
				if(i < middle) {               // 만약에 i가 배열의 중간보다 작다면 왼쪽 배열에 넣기 
					leftArray[i] = array[i];
				} else {                       // 그 반대라면 오른쪽 배열에 넣기
					rightArray[j] = array[i];
					j++;
				}
			}
			mergesort(leftArray);   // 왼쪽 배열을 쪼개기 위한 것
			mergesort(rightArray);  // 오른쪽 배열을 조개기 위한 것
			merge(leftArray, rightArray, array); // 왼쪽 배열과 오른쪽 배열을 비교해서 정렬하여 병합하기 위한 호출 
		}
		
		// 배열의 정렬과 병합
		private static void merge(int[] leftArray, int[] rightArray, int[] array) {
			int leftSize = array.length / 2;  // 왼쪽 배열의 크기 저장		
			int rightSize = array.length - leftSize; // 오른쪽 배열의 크기 저장
			int i = 0,  l = 0, r = 0; // 병합할 배열의 인덱스. i는 원본 배열, l는 왼쪽 배열, r는 오른쪽 배열
			
			// 왼쪽 배열과 오른쪽 배열을 비교 후 작은 값 원본배열에 넣기
			while(l < leftSize && r < rightSize) {  // 왼쪽과 오른쪽이 Size에 도달하면 병합 끝
				if(leftArray[l] < rightArray[r]) {  // 왼쪽의 값이 더 작은지 확인
					array[i] = leftArray[l];        // 왼쪽의 원소가 더 작다면 배열의 값에 왼쪽값을 넣는다.
					i ++;						    // 원본 배열을 다음 원소로 지정하기 위한 인덱스 +1
					l ++;                           // 왼쪽 배열을 다음 원소로 지정하기 위한 인덱스 +1
				} else {                          
					array[i] = rightArray[r];       // 아니면 배열의 값에 오른쪽 값을 넣는다.
					i++;                            // 원본 배열을 다음 원소로 지정하기 위한 인덱스 +1
					r++;                            // 오른쪽 배열을 다음 원소로 지정하기 위한 인덱 +1
				}
			}
			
			// 정렬 후 왼쪽 배열이나 오른쪽 배열에 남는 값을 원본 배열에 전부 넣기
			while(l < leftSize) {           // 왼쪽 배열의 인덱스가 왼쪽배열의 크기에 도달하지 못했다면 아래를 실행
				array[i] = leftArray[l];    // 원본 배열에 왼쪽 배열의 남은 원소 전부 넣기
				i++;
				l ++;
			}
			while(r < rightSize) {          // 오른쪽 배열의 인덱스가 오른쪽 배열의 크기에 도달하지 못했다면 아래를 실행
				array[i] = rightArray[r];   // 원본 배열에 오른쪽 배열의 남은 원소 전부 넣기
				i++;
				r++;
			}
		}
}
